import {
  Box,
  HStack,
  Icon,
  Text,
  Tooltip,
  useMediaQuery,
} from '@chakra-ui/react';
import { DataTable } from '@repo/ui/components';
import { createColumnHelper } from '@tanstack/react-table';
import React, { useMemo } from 'react';
import AssignedTo from '~/lib/components/Common/UserInfo';
import GenericStatusBox from '~/lib/components/UI/GenericStatusBox';
import { TaskInstance } from '~/lib/interfaces/task.interfaces';
import { amountFormatter, dateFormatter } from '~/lib/utils/Formatters';
import PopoverAction from './PopoverAction';
import { InfoIcon } from '~/lib/components/CustomIcons';
import AutoBadge from '~/lib/components/TicketManagement/Drawers/Common/AutoBadge';

const TaskName = (task: TaskInstance) => {
  return (
    <HStack maxW="200px" spacing="8px" overflow="hidden">
      <Box
        width="8px"
        height="8px"
        rounded="full"
        bgColor="#F50000"
        display={task?.isEscalated ? 'flex' : 'none'}
      />
      <Text fontWeight={700} textDecoration="underline">
        {task?.taskInstanceName}
      </Text>
      {task?.isAutoGenerated && <AutoBadge>Auto-Generated</AutoBadge>}
    </HStack>
  );
};

const TaskNameHeader = () => (
  <HStack spacing="8px">
    <Text fontWeight={700}>Task</Text>
    <Tooltip
      label="The colour indicator represents escalated tasks"
      placement="top-start"
      bgColor="black"
      color="white"
      width="181px"
      rounded="4px"
      py="3px"
      px="6px"
      fontSize="10px"
      fontWeight={400}
      hasArrow
    >
      <Icon as={InfoIcon} boxSize="12px" color="blue.500" />
    </Tooltip>
  </HStack>
);

interface TaskInstanceTableProps {
  data: TaskInstance[];
  isLoading?: boolean;
  isFetching?: boolean;
  emptyText?: string;
  showFooter?: boolean;
  emptyLines?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  selectedRows?: number[];
  setSelectedRows?: React.Dispatch<React.SetStateAction<number[]>>;
  handleSelectRow?: React.Dispatch<React.SetStateAction<any>>;
  setPageNumber?: React.Dispatch<React.SetStateAction<number>>;
  setPageSize?: React.Dispatch<React.SetStateAction<number>>;
  isSelectable?: boolean;
  isSortable?: boolean;
  type: 'drawer' | 'page';
  showPopover?: boolean;
  showScheduleId?: boolean;
  showTableBgColor?: boolean;
  isCompleted?: boolean;
}
const TaskInstanceTable = (props: TaskInstanceTableProps) => {
  const {
    data,
    isFetching,
    isLoading,
    isSelectable,
    pageNumber,
    pageSize,
    showFooter,
    emptyText,
    emptyLines,
    totalPages,
    selectedRows,
    isSortable = true,
    handleSelectRow,
    setPageNumber,
    setPageSize,
    setSelectedRows,
    type,
    showPopover = true,
    showScheduleId = true,
    showTableBgColor = true,
    isCompleted,
  } = props;

  const columnHelper = createColumnHelper<TaskInstance>();
  const [isMobile] = useMediaQuery('(max-width: 768px)');

  const columns = useMemo(
    () => {
      const baseColumns = [
        columnHelper.accessor('taskInstanceId', {
          cell: (info) => info.getValue(),
          header: '#',
          enableSorting: false,
        }),
        columnHelper.accessor('taskInstanceName', {
          cell: (info) => TaskName(info.row.original),
          header: () => <TaskNameHeader />,
          enableSorting: false,
        }),
        columnHelper.accessor('taskDescription', {
          cell: (info) => info.getValue() ?? 'N/A',
          header: 'Description',
          enableSorting: false,
        }),
        columnHelper.accessor('priorityName', {
          cell: (info) => {
            return (
              <GenericStatusBox
                colorCode={info.row.original.priorityColorCode}
                text={info.getValue() as string}
              />
            );
          },
          header: 'Priority',
          enableSorting: isSortable,
        }),
        columnHelper.accessor('estimatedDurationInHours', {
          cell: (info) => {
            const value = info.getValue();
            return value && value !== null
              ? `${value} hour${value > 1 ? 's' : ''}`
              : 'N/A';
          },
          header: 'Estimated Duration',
          enableSorting: false,
        }),
        columnHelper.accessor('costEstimate', {
          cell: (info) =>
            info.getValue() ? amountFormatter(info.getValue()) : 'N/A',
          header: 'Estimate Cost',
          enableSorting: false,
        }),
        columnHelper.accessor('assignedToEmployeeName', {
          cell: (info) => <AssignedTo name={info.getValue()} />,
          header: 'Assigned To',
          enableSorting: isSortable,
        }),
        columnHelper.accessor('currentStatus', {
          cell: (info) => {
            return (
              <GenericStatusBox
                colorCode={info.row.original.statusColorCode}
                text={info.getValue() as string}
              />
            );
          },
          header: 'Status',
          enableSorting: false,
        }),
      ];
      const popOverColumns = columnHelper.accessor('taskInstanceGuid', {
        cell: (info) => PopoverAction(info.row.original, type),
        header: '',
        enableSorting: false,
      });

      const scheduleColumn = columnHelper.accessor('scheduleInstanceId', {
        cell: (info) => info.getValue(),
        header: 'Schedule ID',
        enableSorting: false,
      });

      const completedColumn = columnHelper.accessor('dateCompleted', {
        cell: (info) =>
          dateFormatter(info.getValue(), 'DD / MM / YYYY') ?? 'N/A',
        header: 'Completion Date',
        enableSorting: isSortable,
      });

      if (showScheduleId) {
        baseColumns.splice(3, 0, scheduleColumn);
      }

      if (isCompleted) {
        baseColumns.splice(5, 0, completedColumn);
      }

      if (showPopover) {
        baseColumns.push(popOverColumns);
      }
      return baseColumns;
    },
    [[data]] //eslint-disable-line
  );

  const mobileColumns = useMemo(
    () => {
      const baseColumns = [
        columnHelper.accessor('taskInstanceId', {
          cell: (info) => info.getValue(),
          header: '#',
          enableSorting: false,
        }),
        columnHelper.accessor('taskInstanceName', {
          cell: (info) => TaskName(info.row.original),
          header: () => <TaskNameHeader />,
          enableSorting: false,
        }),

        columnHelper.accessor('assignedToEmployeeName', {
          cell: (info) => <AssignedTo name={info.getValue()} />,
          header: 'Assigned To',
          enableSorting: isSortable,
        }),
      ];
      const popOverColumns = columnHelper.accessor('taskInstanceGuid', {
        cell: (info) => PopoverAction(info.row.original, type),
        header: '',
        enableSorting: false,
      });

      if (showPopover) {
        baseColumns.push(popOverColumns);
      }
      return baseColumns;
    },
    [[data]] //eslint-disable-line
  );
  return (
    <>
      <DataTable
        columns={isMobile ? mobileColumns : columns}
        data={data ?? []}
        isLoading={isLoading}
        isFetching={isFetching}
        totalPages={totalPages}
        setPageNumber={setPageNumber}
        pageNumber={pageNumber}
        pageSize={pageSize}
        setPageSize={setPageSize}
        handleSelectRow={(row) => {
          handleSelectRow && handleSelectRow(row);
          // Commenting this out because it affects the clicking of the popover action
          // const taskSlugName = SYSTEM_CONTEXT_DETAILS.TASKS.slug;

          // updateSearchParam(taskSlugName, row?.taskInstanceGuid);
        }}
        selectedRows={selectedRows}
        setSelectedRows={setSelectedRows}
        showFooter={showFooter}
        emptyText={emptyText}
        emptyLines={emptyLines}
        isSelectable={isSelectable}
        maxTdWidth="200px"
        customThStyle={{
          paddingLeft: '16px',
          paddingTop: '12px',
          paddingBottom: '12px',
          fontWeight: 700,
        }}
        customTdStyle={{
          paddingLeft: '16px',
          paddingTop: '12px',
          paddingBottom: '12px',
        }}
        customTableContainerStyle={{
          rounded: 'none',
          bgColor: showTableBgColor ? 'white' : 'transparent',
        }}
        paginationStyle={{
          bgColor: showTableBgColor ? 'white' : 'transparent',
        }}
      />
    </>
  );
};

export default TaskInstanceTable;
